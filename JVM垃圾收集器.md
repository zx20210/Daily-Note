# JVM垃圾收集器

​	说到垃圾收集器，就要先讲一下垃圾收集算法，由于各个平台的虚拟机操作内存的方法各不相同，只讲集中垃圾收集算法的思想。



#### 标记清除算法

**算法描述：** 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

后续的算法都是在这一算法的基础上进行改进的。

**不足之处：** 

1. 效率问题，标记和清除效率都不高。

1. 空间问题，标记清除之后会产生大量不连续的内存碎片。

#### 复制算法

**算法描述：** 将可用内存按容量划分为大小相等的两块，每次只用其中的一块。当前内存块用满了就将还存活着的对象复制到另一块内存上，然后清除当前内存块。实现简单，运行高效。

**不足之处：**

将内存缩小成原来的一半，空间利用率不高。



现在的虚拟机都采用这种方法回收新生代，由于新生代中的对象98%都是朝生夕死的，所以可以按照8:1:1的比例来划分出三块内存：一块eden，两块survivor。回收时，将eden和survivor中还存活的对象一次性地复制到另一块survivor上，然后清理掉原来的eden和survivor上的空间。在保持高效的同时还减少了浪费的内存。



#### 标记整理算法

若对象的存活率较高，每次清理都需要做大量的复制操作，效率降低。所以前面所说两种算法不好用于对象存活率很高的老年代。

**算法描述：**标记过程和标记清除相同，然而后续步骤是让所有尚还存活的对象像内存一端移动，然后清理掉端边界以外的内存。



#### 分代收集算法

商业虚拟机的垃圾收集都采用“分代收集”。

算法描述：并无新的思想，只是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后就可以根据新生代和老年代的特点来选择适合的算法。一般来说新生代使用复制算法，老年代使用标记回收或者标记整理。



------

#### Serial收集器

单线程收集器，同时在进行垃圾收集时，必须暂停其他所有的工作线程，并且是在用户不可见的情况下。

新生代采取复制算法，老年代采取标记整理算法。

#### ParNew收集器

Serial收集器的多线程版本。除了Serial收集器外，只有他可以和CMS收集器配合工作。

#### Parallel Scavenge收集器

多线程，新生代复制算法，老年代标记整理算法。

特性是该收集器重点达到一个可控制的吞吐量。

吞吐量 = 运行用户代码时间  / （运行用户代码时间 + 垃圾收集时间）

使用 -XX: MaxGCPauseMillis控制最大垃圾收集停顿时间，-XX:GCTimeRatio设置吞吐量大小。

GC停顿时间的缩短是牺牲吞吐量和新生代空间来换取的。停顿时间缩短同样也会导致收集更加频繁，但是对于用户来说交互效果确实提高了。

### CMS收集器（Concurrent Mark Sweep）

**运作步骤**：

初始标记：需要stop the world，标记GC roots能直接关联到的对象。

并发标记：进行GC roots Tracing的过程。

重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记纪录。

并发清除：略。

过程中耗时最长的并发标记和并发清除可以和用户线程一起工作，而初始标记和重新标记由于任务简单，停顿线程的时间也没有那么长。

**缺点**：

对CPU资源非常敏感：占用线程导致用户程序变慢，总吞吐量降低。

无法处理浮动垃圾：对于这一次标记之后产生的垃圾，只能在下次标记开始之后清除。

空间碎片问题：CMS是基于标记清除算法，所以在垃圾收集完成之后会产生大量的空间碎片。



### G1收集器

**特点：**

并行与并发：充分利用多CPU、多核环境下的硬件优势来缩短Stop the world的时间。

分代收集：分代收集。

空间整合：与CMS的标记清除算法不同，（整体上看）G1是基于标记整理算法实现的收集器。

可预测的停顿：停顿可预测。



使用G1收集器时，Java堆被划分为多个大小相等的独立区域（region），新生代和老年代的概念依旧保存，但是他们在这里是一部分Region的集合（不一定连续）。

G1有计划地避免在整个Java堆进行全区域的垃圾收集，所以可以预测到停顿时间。G1跟踪各个region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的Region。保证了G1在有限的时间内可以获取尽可能高的收集效率。

具体的实现中，Java堆被分为多个Region，一个对象分配在某个Region中，但是他并非只能被同一个Region中的其他对象引用，其他Region的对象也可以引用他，那么如果要确保对象是否存活，还是要扫描全堆？

###### Remembered Set

在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描。

每个Region都有一个与之对应的Remembered Set，在虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，若是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。



忽略Remembered Set的操作，G1收集器的运作大致划分如下：

**初始标记：**标记GC roots直接关联到的对象，修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，需要停顿线程。

**并发标记：** 从GC Root开始对堆中对象进行可达性分析，找出存活的对象，与用户程序并发执行。

**最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记纪录。这段时间对象变化会记录在Remembered Set Logs里面，最终标记阶段需要吧Remembered Set Logs的数据合并到Remembered Set中，需要停顿，但是可以并行。

**筛选回收：** 首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。可不停顿，但停顿收集效率更高。
